# Базовый пример #

В этом примере будет дана пошаговая инструкция по подготовке рабочей среды для создания плагина Quik при помощи библиотеки qluacpp.
Создаваемый плагин будет обладать простейшим функционалом: в первые пять секунд после запуска скрипта каждую секунду выводить сообщение при помощи стандартной функции message терминала Quik, после чего завершит работу.

![Tick message screenshot](doc/message_screenshot.png)

Приглагаемый код плагина можно скомпилировать примерно следующим образом из Developer Command Prompt (32-битного) от MSVS:
```
git clone --recurse-submodules https://github.com/elelel/qluacpp-tutorial.git c:\source\basic_tutorial
mkdir c:\build\basic_tutorial_basic
cd c:\build\basic_tutorial_basic
cmake -G "NMake Makefiles" -DLUA_INCLUDE_DIR=c:\lib\lua\include -DLUA_LIBRARIES=c:\lib\lua\lua51.lib c:\source\basic_tutorial\basic
nmake
```

Более подробно инструкции даны в тексте этого документа.

## Цель примера и приобретаемые навыки ##
 * Создание с нуля "пустого" проекта QluaCpp
 * Использование простейшей функции message Qlua

## Используемые программы ##

Для написания и запуска плагина понадобится ряд программ.

### Терминал Quik ###

Торговый терминал Quik понадобится только для запуска плагина, написание кода и сборка возможна без него

### Git ###

Система контроля версий git понадобится для скачивания библиотек и их зависимостей.
Установка другим способом находящихся под git библиотек данного проекта не рекомендуется, поскольку в их
структуре используются подмодули, обеспечивая соответствие версий зависимостей.

### CMake ###

Библиотека qluacpp является header-only библиотекой. Использование CMake не обязательно при использовании qluacpp, но для удобства сам пример будет разрабатываться с использованием CMake.

### Компилятор ###

Для сборки этого примера потребуется NMake, входящий в состав Microsoft Visual Studio или Windows Development Tools.
Сама IDE не потребуется, хотя будет показано, как сгенерировать проект Visual Studio из CMake. В примере
использовалась Visual Studio 2017

### Текстовый редактор ###

Для написания кода и других файлов примера используется только текстовый редактор, что делает разработку независимой от
среды. Можно использовать любой текстовый редактор: от Visual Studio, Notepad и т.п. При создании этого примера использовался Emacs.

## Начальная структура проекта ##

На файловой системе проект плагина будет выглядеть следующим образом

[../contrib](../contrib) - директория для сторонних библиотек, в том числе qluacpp.
Обратите внимание, чтоб эта директория находится в корневой директории примеров (на один уровень выше директории этого примера).

[src](src) - исходные файлы нашего плагина

Создаем указанные выше директории, после чего помещаем наш проект под систему контроля версий git.
Если используется совместимый со стандартным git, для этого открываем Command Prompt от Windows, заходим в директорию проекта и выполняем:

```git init```

В дальнейшем подразумевается, что читатель будет по мере необходимости самостоятельно делать ```git commit```

## Установка сторонних библиотек ##

### Установка QluaCpp ###

В директории contrib проекта для установки qluacpp исполняем команду:

```git submodule add https://github.com/elelel/qluacpp.git```

Для обновления зависимостей подмодуля исполняем:

```git submodule update --init --recursive```

### Установка Lua ###

#### Скачивание нужной версии библиотеки ####

Скачиваем наиболее близкую по major версии к версии модифицированной Lua, включенной в Quik, оригинальную библиотеку Lua на Sourceforge официальном сайте. На момент написания данного документа одни брокеры используют Quik с Lua 5.1, другие перешли на Quik с Lua 5.3. Примеры написаны для Lua 5.1 и будут в дальнейшем обновлены для поддержки 5.3. Если вам требуется настроить проект для Quik с Lua 5.3, посмотрите этот issue: https://github.com/elelel/qluacpp-tutorial/issues/28

Чтобы скачать библиотеку Lua идем на страницу скачивания библиотеки на Sourceforge: [https://sourceforge.net/projects/luabinaries/files/]()

На момент написания данного документа максимальной версией в рамках ветви 5.1 является версия 5.1.5. Переходим в этот каталог, где далее выбираем **Windows Libraries** и **Dynamic**.

Выбираем архив, ближайщий к нашему сценарию использования.
Например, на момент написания для Win32, dll, 14 = **lua-5.1.5_Win32_dll14_lib.zip**; для Win64, dll, 15 = **lua-5.1.5_Win64_dll15_lib.zip** 

В директории [contrib](../contrib) создаем директорию *lua*. Копируем туда содержимое скаченного оригинального архива с библиотекой Lua.

## Создание CMake проекта ##

В директории проекта создаем файл [CMakeLists.txt](CMakeLists.txt)

В начале файла указываем:

```cmake
cmake_minimum_required(VERSION 3.4.0)
project(basic_tutorial)
```

Создаем переменные с путями к используемым в проекте библиотекам и их зависимостям:

```cmake
get_filename_component(TOP_DIR "${CMAKE_CURRENT_SOURCE_DIR}" PATH)
set(QLUACPP "${TOP_DIR}/contrib/qluacpp")
set(LUACPP "${TOP_DIR}/contrib/qluacpp/contrib/luacpp")
set(LUA "${TOP_DIR}/contrib/lua")
```

Устанавлиаем переменные с указанием пути к файлам библиотеки lua.
Для lib-файла делаем это через переменную LUA_LIBRARIES, настроив ее на путь к скаченному lib-файлу библиотеки Lua:

```cmake
set(LUA_LIBRARIES "${LUA}/lua5.1.lib")
```

Указываем путь к загаловкам скаченной библиотеки Lua:

```cmake
set(LUA_INCLUDE_DIR "${LUA}/include")
```

Перечисляем директории, которые должны быть доступны для директивы ```#include``` препроцессора. Они включают и include-директории зависимостей используемых проектом библиотек.

```cmake
include_directories(
  ${QLUACPP}/include
  ${LUACPP}/include
  ${LUA_INCLUDE_DIR}
)
```

Перечисляем исходные файлы нашего плагина:

```cmake
set(SOURCES
  src/basic_tutorial.cpp
)
```

Указываем, что мы хотим создать DLL:

```cmake
add_library(lualib_basic_tutorial SHARED ${SOURCES})
```

Указываем конфигурацию линковки (подсоединяем нужные библиотеки к компилируемой dll):

```cmake
target_link_libraries(lualib_basic_tutorial ${LUA_LIBRARIES})
```

## Пишем код плагина ##

### Создание едиственного исходного файла примера ###

Создаем файл [basic_tutorial.cpp](src/basic_tutorial.cpp) в директории [src](src) и открываем его в редакторе.

Декларируем через директивы препроцессора, что мы создаем "библиотеку" Lua:

```c++
#define LUA_LIB
#if defined(WIN32) || defined(_WIN32) || defined(__WIN32)
  #define LUA_BUILD_AS_DLL
#endif
```

Подключаем заголовки из стандартной библиотеки для работы со временем и потоками (используются, чтоб делать паузу в функции main).

```c++
#include <chrono>
#include <thread>
```

После этого подключаем библиотеку qluacpp:

```c++
#include <qlua>
```

Создаем пустую глобальную структуру для интерфейса наших "библиотечных" функций для Lua:

```c++
static struct luaL_reg ls_lib[] = {
  { NULL, NULL }
};
```

Создаем обработчик Lua-функции main:
```c++
void my_main(lua::state& l) {
  using namespace std::chrono_literals;
  qlua::api q(l);
  q.message("qluacpp tutorial: Starting main handler");
  for (int i = 0; i < 5; ++i) {
    q.message(("qluacpp tutorial: Tick " + std::to_string(i)).c_str());
    std::this_thread::sleep_for(1s);
  }
  q.message("qluacpp tutorial: Terminating main handler");
}
```

Декларируем структуры Luacpp для обработчика main. Цифра "2" в конце имени макроса указывает количество параметров к макросу.
Первый аргумент содержит имя функции внутри Lua, второй - имя соответствующей ей функции C++ в нашем коде:

```c++
LUACPP_STATIC_FUNCTION2(main, my_main)
```
Создаем видимую извне функцию с C ABI, которая будет инициализировать "библиотеку":

```c++
extern "C" {
  LUALIB_API int luaopen_lualib_basic_tutorial(lua_State *L) {
    // Here will be code...
    return 0;
  }
}
```

Внутри функции *luaopen_lualib_basic_tutorial* из указателя на структуру с состоянием Lua создаем объект интерфейса Lua с C++:

```c++
    lua::state l(L);
```

Подключаем наш обработчик для функции main qlua-скрипта. Для этого регистрируем через ранее объявленный вспомогательный класс для функции main в качестве соответствующей ей функции функцию my_main. Эта функция будет видна из
Lua как main (имя в Lua соответствует продекларированному в классе) и терминал Quik будет ее вызывать при описанных в файле помощи qlua.chm обстоятельствах:

```c++
    ::lua::function::main().register_in_lua(l, my_main);
```

Наконец, подключаем нашу "библиотеку" к Lua:

```c++
luaL_openlib(L, "lualib_basic_tutorial", ls_lib, 0);
```

## Сборка проекта ##

В любом удобном месте, не внутри директории с репозитарием проекта, мы должны создать директории, в которые будет сгенерирован при помощи CMake проект под нужную нам среду.

В меню Start Windows ищем Command Prompt for VS2017. При выборе следует помнить, под какую разрядность системы компилируется проект. Поэтому, если компиляция происходит, например , на 64-битном Windows под 32-битный Quik, следует выбирать x64_x86 Cross Tools Command Prompt.



### Компиляция проекта при помощи NMake ###

NMake - мейкер от Microsoft, который поставляется в составе Visual Studio, Windows Developer Tools и др.

Создаем директорию *basic_tutorial_nmake*

Заходим в нее и выполняем:
```
"c:\Program Files\CMake\bin\cmake.exe" -G "NMake Makefiles" c:\path\basic_tutorial\code
```
где последний аругмент - путь к коду проекта, а опция -G указывает, под какую среду генерировать проект.

Далее запускаем:

```
NMake
```
В результате будет скомпилирован файл DLL нашего плагина, который можно использовать как Lua "библиотеку" в Quik.


### Проект (solution)  IDE Visual Studio ###

Cоздаем директорию *basic_tutorial_vs*. Заходим в нее и выполняем:
```
"c:\Program Files\CMake\bin\cmake.exe" -G "Visual Studio 15 2017" c:\path\basic_tutorial\code
```
где последний аругмент - путь к коду проекта, а опция -G указывает, под какую среду генерировать проект.
Для 64-битных целей компиляции следует указывать битность, например **-G "Visual Studio 15 2017 Win64"**

После этого в указанной директории будет создан проект Visual Studio нашего плагина. Описание дальнейшей работы с Visual Studio не является предметом данного документа.


## Установка плагина в терминал Quik ##

Если в директории терминала **Quik** нет файла lua5.1.dll (прокси-библиотеки с интерфейсом Lua от Arqa), но есть lua51.dll, создаем копию файла lua51.dll и называем ее lua5.1.dll, для соответствия идентификаторам, используемым в родном файле lua5.1.lib из состава архива Lua, который мы скачивали на этапе установки библиотек.

Копируем скомпилированный файл плагина **lualib_basic_tutorial.dll** в директорию **Quik**.

Создаем в директории **Quik** lua-скрипт **basic_tutorial.lua**, грузящий нашу "библиотеку Lua" и содержащий единственную строку:

```lua
require "lualib_basic_tutorial"
```

Для запуска плагина в терминале **Quik** (info.exe) добавляем и запускаем Lua-скрипт basic_tutorial.lua

